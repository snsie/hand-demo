/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three';
import React, { memo, useMemo, useRef, useState } from 'react';
import {
  // Text,
  useGLTF,
} from '@react-three/drei';
import { GLTF } from 'three-stdlib';
import { useFrame, useThree } from '@react-three/fiber';
import getQuatWrist from '@/utils/get-quat-wrist';
import getVecOrth from '@/utils/get-vec-orth';
import getQuatTransformed from '@/utils/get-quat-transformed';
import { handIndices } from '@/utils/store';
import getRotMcp from '@/utils/get-rot-mcp';
import getRotThumb from '@/utils/get-rot-thumb';
import getBoneName from '@/utils/get-bone-name';
import logArray from '@/utils/log-array';

type GLTFResult = GLTF & {
  nodes: {
    hand: THREE.SkinnedMesh;
    bone000: THREE.Bone;
  };
  materials: {
    ['Material #46']: THREE.MeshStandardMaterial;
  };
};
// const quatWrist = new THREE.Quaternion();
// const quatWristSmoothed = new THREE.Quaternion(0, 0, 0, 1);

const wristPosition = new THREE.Vector3();

// const quat1 = new THREE.Quaternion();
// const quat2 = new THREE.Quaternion();
// const eul1 = new THREE.Euler();
// const vec1 = new THREE.Vector3();
// const vec2 = new THREE.Vector3();
// // const vecOrtho = new THREE.Vector3();
// // const vecFrom = new THREE.Vector3();
// // const vecTo = new THREE.Vector3();
// const mat = new THREE.Matrix4();
// const boneTemp = new THREE.Bone();
// const matInv = new THREE.Matrix4();
// const axis = new THREE.Vector3(0, 1, 0);
// const vectorTrack1 = new THREE.Vector3();

const pointIndexMcp = 5;
const pointIndexPip = 6;
const pointIndexDip = 7;
const pointMidMcp = 9;
export default function HandMeshR({ basePosRef, keypoints3dRef, ...props }) {
  const groupRef = useRef<THREE.Group>(null!);
  const textRef = useRef<THREE.Mesh>(null!);
  const { nodes, materials } = useGLTF(
    '/gltf/hand_model_parented_sub_right.glb'
  ) as GLTFResult;
  // console.log(nodes);
  // const array1Ref = useRef('');
  // const array2Ref = useRef([0, 0, 0]);

  // const axesRef = useRef<THREE.AxesHelper>(null!);
  // const axesRef2 = useRef<THREE.AxesHelper>(null!);
  // const skeletonInit = useMemo(
  //   () => nodes.hand.skeleton.computeBoneTexture(),
  //   [nodes]
  // );
  // const [text1State, setText1State] = useState('[0, 0, 0]');
  const skinnedMeshRef = useRef<any>(null!);
  // useEffect(() => {
  //   // indexMcp.quaternion.identity();
  //   quatIndexMcpBase.copy(indexMcp.quaternion);
  //   quatIndexPipBase.copy(indexPip.quaternion);
  //   // quatIndexMcp.invert();
  //   // quatWrist.copy(wrist.quaternion);
  //   // baseQuatIndexMcp.copy(indexMcp.quaternion);
  // }, []);

  const { clock, viewport } = useThree();
  // const prevVectorRef = useRef([0, 0, 1]);
  // useEffect(() => {
  //   const initialQuats: number[] = [];

  //   for (let i = 0; i < skinnedMeshRef.current.skeleton.bones.length; i++) {
  //     // boneTemp.copy(
  //     //   skinnedMeshRef.current.skeleton.getBoneByName(`${getBoneName(i)}`)
  //     // );
  //     const bone = skinnedMeshRef.current.skeleton.getBoneByName(
  //       `${getBoneName(i)}`
  //     );

  //     // initialQuats;
  //     console.log(bone);
  //   }
  // }, []);
  useFrame(() => {
    // const midMcp = skinnedMeshRef.current.skeleton.getBoneByName(
    //   `${addZeros(9, 3)}`
    // ) as THREE.Bone;

    // const indexMcp = skinnedMeshRef.current.skeleton.getBoneByName(
    //   `${addZeros(5, 3)}`
    // ) as THREE.Bone;
    // const indexPip = skinnedMeshRef.current.skeleton.getBoneByName(
    //   `${addZeros(6, 3)}`
    // ) as THREE.Bone;
    // const indexDip = skinnedMeshRef.current.skeleton.getBoneByName(
    //   `${addZeros(7, 3)}`
    // ) as THREE.Bone;

    wristPosition.set(
      viewport.width * basePosRef.current[0],
      viewport.height * basePosRef.current[1],
      0
    );
    groupRef.current.position.lerp(wristPosition, 0.65);
    getQuatWrist(
      'Left',
      groupRef.current,
      skinnedMeshRef.current.skeleton,
      keypoints3dRef.current,
      0,
      5,
      13
    );
    // nodes.hand.matrixWorldNeedsUpdate = true;

    // console.log(nodes.hand.updateMatrixWorld());

    // console.log(nodes.hand.matrixWorld.toArray());
    // );

    // wrist.quaternion.slerp(quatWrist, 0.7);

    // console.log(wrist.matrix.toArray());
    // console.log(
    //   quatWrist
    //     .toArray()
    //     .map((val) => val.toFixed(4))
    //     .join()
    // );
    // wrist.quaternion.slerp(quatWrist, 0.65);
    // wrist.applyQuaternion(quatWrist);

    // indexMcp.getWorldPosition(vecBonePos0);
    // indexPip.getWorldPosition(vecBonePos1);
    // // midMcp.getWorldPosition(vecBonePos2);
    // // // pointMidMcp
    // vectorBone.subVectors(vecBonePos1, vecBonePos0).normalize();
    getRotMcp(
      skinnedMeshRef.current.skeleton,
      keypoints3dRef.current,
      handIndices.pinkyMcp
    );
    getRotMcp(
      skinnedMeshRef.current.skeleton,
      keypoints3dRef.current,
      handIndices.indexMcp
    );
    getRotMcp(
      skinnedMeshRef.current.skeleton,
      keypoints3dRef.current,
      handIndices.middleMcp
    );

    getRotMcp(
      skinnedMeshRef.current.skeleton,
      keypoints3dRef.current,
      handIndices.ringMcp
    );

    getRotThumb(
      skinnedMeshRef.current.skeleton,
      keypoints3dRef.current,
      handIndices.thumbCmc
    );
    // const thumbMcpInit = skeletonInit.getBoneByName(
    //   `${getBoneName(1)}`
    // ) as THREE.Bone;
    // const thumbMcp = skinnedMeshRef.current.skeleton.getBoneByName(
    //   `${getBoneName(1)}`
    // ) as THREE.Bone;
    // quat1.copy(thumbMcp.quaternion);
    // axesRef.current.quaternion.slerp(quat1, 0.5);
    // quat1.copy(thumbMcp.quaternion);
    // thumbMcp.getWorldQuaternion(quat2);
    // vec1.set(0, 1, 0);
    // vec1.applyQuaternion(quat1);
    // console.log(quat1);
    // console.log(quat2);

    // thumbMcp.up.copy(vec1);
    // thumbMcp.lookAt(-10, 10, 0);
    // console.log(thumbMcp.rotation.set(0, 0, 0));
    // console.log(group.current.children[1].position.);
    // const bone = skinnedMeshRef.current.children[0];
    // console.log(thumbMcp.matrixWorld.toArray());
    // mat.copy(thumbMcp.matrix).invert();
    // quat1.copy(thumbMcp.quaternion);
    // eul1.copy(thumbMcp.rotation);
    // // mat.makeRotationX(Math.PI / 2);
    // // eul1.x = Math.PI / 2;
    // quat2.copy(thumbMcp.quaternion);
    // thumbMcp.matrixAutoUpdate = false;

    // console.log(vec2.toArray());
    // console.log(
    //   'eul',
    //   quat1
    //     .toArray()
    //     .map((val) => val.toFixed(4))
    //     .join()
    // );
    // vec1.set(-1, 0, 0).normalize();
    // vec1.applyQuaternion()
    // console.log(
    //   'bone',
    //   thumbMcp.rotation.toArray().map((val) => typeof val)
    // );
    // logArray(eul1.toArray());
    // thumbMcp.rotation.copy(eul1);
    // thumbMcp.rotation.set(0, Math.PI, 0);
    // vec1.applyEuler(thumbMcp.rotation);
    // thumbMcp.rotation.y = -2*(1 + Math.sin(clock.getElapsedTime()));
    // thumbMcp.rotation.y = -2 *  clock.getElapsedTime();

    // thumbMcp.rotation.y = -Math.PI / 2.4;
    // quat1.copy(skinnedMeshRef.current.skeleton.bones[0].quaternion).invert();
    // vec1.applyQuaternion(quat1);
    // logArray(skinnedMeshRef.current.skeleton.bones[0].quaternion.toArray());

    // console.log(skinnedMeshRef.current.skeleton.bones[0].quaternion);
    // ///////////////////////////////////////////////
    // thumbMcp.setRotationFromAxisAngle()
    // vec1.transformDirection(thumbMcp.matrix);
    // thumbMcp.d
    // thumbMcp.lookAt(vec1);
    // thumbMcp.matrix.premultiply(mat);
    // thumbMcp.updateMatrix();
    // console.log(thumbMcp.matrix.toArray());
    // matInv.copy(thumbMcp.matrix).invert();
    // mat.makeRotationX(Math.PI / 2);
    // thumbMcp.rotateOnAxis(axis, Math.PI / 2);
    //
    // thumbMcp.matrix.copy(mat);
    // thumbMcp.updateMatrix();
    // thumbMcp.rotation.x = 0;
    // const thumbDip = skinnedMeshRef.current.skeleton.getBoneByName(
    //   `${addZeros(2, 3)}`
    // ) as THREE.Bone;
    // thumbDip.rotation.x = Math.PI / 2;
    // const index0 = 0;

    // const index1 = 1;
    // const index2 = 2;

    // vecFrom
    //   .set(
    //     keypoints3dRef.current[index2 * 3 + 0] -
    //       keypoints3dRef.current[index1 * 3 + 0],
    //     keypoints3dRef.current[index2 * 3 + 1] -
    //       keypoints3dRef.current[index1 * 3 + 1],
    //     keypoints3dRef.current[index2 * 3 + 2] -
    //       keypoints3dRef.current[index1 * 3 + 2]
    //   )
    //   .normalize();
    // vecTo
    //   .set(
    //     keypoints3dRef.current[index1 * 3 + 0] -
    //       keypoints3dRef.current[index0 * 3 + 0],
    //     keypoints3dRef.current[index1 * 3 + 1] -
    //       keypoints3dRef.current[index0 * 3 + 1],
    //     keypoints3dRef.current[index1 * 3 + 2] -
    //       keypoints3dRef.current[index0 * 3 + 2]
    //   )
    //   .normalize();
    // vecOrtho.crossVectors(vecFrom, vecTo);
    // const thumbAngle = -Math.PI * Math.max(0, vecOrtho.length() - 0.25);
    // console.log(thumbAngle);
    // thumbMcp.rotation.y = thumbAngle;
    // ////////////////////////////////////////////////////////////

    // getRotMcp(
    //   skinnedMeshRef.current.skeleton,
    //   keypoints3dRef.current,
    //   handIndices.indexPip,
    //   handIndices.indexDip
    // );

    // getRotMcp(
    //   wrist.quaternion,
    //   skinnedMeshRef.current.skeleton,
    //   keypoints3dRef.current,
    //   handIndices.indexPip,
    //   handIndices.indexDip
    // );
    // vectorTrack
    //   .set(
    //     keypoints3dRef.current[pointIndexDip * 3 + 0] -
    //       keypoints3dRef.current[pointIndexPip * 3 + 0],
    //     keypoints3dRef.current[pointIndexDip * 3 + 1] -
    //       keypoints3dRef.current[pointIndexPip * 3 + 1],
    //     keypoints3dRef.current[pointIndexDip * 3 + 2] -
    //       keypoints3dRef.current[pointIndexPip * 3 + 2]
    //   )
    //   .normalize();
    // quaternion1.copy(wrist.quaternion).invert();
    // vectorTrack.applyQuaternion(quaternion1);

    // console.log(vectorTrack);

    // // const xRot = Math.sin(clock.getElapsedTime());

    // indexMcp.rotation.x = (Math.PI / 2) * vectorTrack.z;

    // indexMcp.rotation.y = -Math.PI / 10;
    // indexPip.rotation.x = Math.PI / 2;
    // indexDip.rotation.x = Math.PI / 2;
    // indexMcp.rotation.z = 0;
    // indexPip.
    // indexMcp.quaternion.x = xRot;
    // indexMcp.quaternion.w = Math.sqrt(1 - xRot * xRot);
    // console.log(indexMcp.quaternion.w);
    // console.log(indexMcp.quaternion);
    // indexPip.quaternion.slerp(quatIndexPip, 0.5);

    // indexDip.quaternion.slerp(quatIndexPip, 0.5);

    // console.log(indexPip);
    // indexTip.quaternion.slerp(quatIndexPip, 0.7);
    // indexPip.get(vecFrom);
    // vecTo.set(0, 1, 0);
    // indexMcp.lookAt(vecTo);
    // quatIndexMcp.copy(quatIndexMcpBase).premultiply(quatWrist);
    // getQuatWrist(
    //   quatIndexMcp,
    //   skinnedMeshRef.current.skeleton,
    //   keypoints3dRef.current,
    //   5,
    //   6,
    //   9
    // );
    // quatIndexMcp.premultiply(wrist.quaternion);
    // quatIndexMcp.premultiply()
    // quatIndexMcp.invert();
    // indexMcp.getWorldDirection(vectorBone);
    // quaternion1.copy(quatWrist);
    // vectorBone.applyQuaternion(quaternion1);
    // quatIndexMcp.premultiply(quatWrist);

    // console.log(
    //   vecTo
    //     .toArray()
    //     .map((val) => val.toFixed(4))
    //     .join()
    // );
    // indexMcp.quat;
    // indexMcp.quaternion.copy(quatIndexMcp);

    // quaternion1.setFromUnitVectors(vectorBone, vectorTrack);
    // quatIndexMcp.multiply(quaternion1);
    // console.log(quaternion1.lengthSq());
    // .premultiply(quatWrist)
    // .premultiply(indexMcp.quaternion);
    // indexMcp.quaternion;
    // ////////////////////////////
    // console.log(vectorTrack);
    // vecFrom.copy(getVecOrth(vecBonePos0, vecBonePos1, vecBonePos2));
    // vecBonePos0.set(
    //   keypoints3dRef.current[pointIndexMcp * 3 + 0],
    //   keypoints3dRef.current[pointIndexMcp * 3 + 1],
    //   keypoints3dRef.current[pointIndexMcp * 3 + 2]
    // );
    // vecBonePos1.set(
    //   keypoints3dRef.current[pointIndexPip * 3 + 0],
    //   keypoints3dRef.current[pointIndexPip * 3 + 1],
    //   keypoints3dRef.current[pointIndexPip * 3 + 2]
    // );
    // vecBonePos2.set(
    //   keypoints3dRef.current[pointMidMcp * 3 + 0],
    //   keypoints3dRef.current[pointMidMcp * 3 + 1],
    //   keypoints3dRef.current[pointMidMcp * 3 + 2]
    // );
    // vecTo.copy(getVecOrth(vecBonePos0, vecBonePos1, vecBonePos2));

    // vecTo;
    // quaternion1.setFromUnitVectors(vectorBone, vectorTrack);
    // // .multiply(baseQuatIndexMcp);
    // // .multiply(quatWrist);

    // indexMcp.quaternion.copy(quaternion1);
    //   quaternion1.premultiply(quatWrist).multiply(baseQuatIndexMcp),
    //   0.75
    // );
    //   .premultiply(quatWrist);

    // quaternion2.copy(wrist.quaternion);
    // getQuatWrist(
    //   quaternion1,
    //   skinnedMeshRef.current.skeleton,
    //   keypoints3dRef.current,
    //   5,
    //   6,
    //   13
    // );
    // quaternion2.multiplyQuaternions(quatWrist, quaternion1);
    // console.log(indexMcp.quaternion);
    // indexMcp.quaternion.slerp(quaternion1, 0.75);
    // console.log(baseQuatIndexMcp);
    // quaternion2.copy(indexMcp.quaternion);
    // quaternion1
    //   .copy(getQuatWrist(skinnedMeshRef.current.skeleton, keypoints3dRef.current, 5, 6, 9))
    //   .multiply(quatWrist);

    // quaternion1
    //   .setFromUnitVectors(vectorBone, vectorTrack)
    //   .premultiply(quatWrist);
    // // quatFinal
    // midMcp.getWorldPosition(vecBonePos1);

    // quaternion2.premultiply(quaternion1).premultiply(quatWrist);

    // indexMcp.quaternion.slerp(quaternion1, 0.75);
    // console.log(indexMcp.quaternion);
    // console.log(indexPip.quaternion);
    // wrist.quaternion.slerp(quatWrist);

    // indexPip.quaternion.z += 0.1;

    // indexPip.rotation.x += 0.1;
  });
  return (
    <group ref={groupRef} dispose={null} {...props}>
      <primitive object={nodes.bone000} />
      <skinnedMesh
        ref={skinnedMeshRef}
        geometry={nodes.hand.geometry}
        material={materials['Material #46']}
        skeleton={nodes.hand.skeleton}
      />
      {/* <axesHelper ref={axesRef} args={[2]} /> */}
    </group>
  );
}

// useGLTF.preload('/gltf/hand_model_parented_sub.glb');

// setText1State(
//   wrist.position
//     .copy(wristPosition)
//     .toArray()
//     .map((val) => val.toFixed(4))
//     .join()
// );
// const HandMesh = () => HandMeshSingle;
// export default HandMesh;
