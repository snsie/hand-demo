/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three';
import React, { useEffect, useRef, useState } from 'react';
import {
  // Text,
  useGLTF,
} from '@react-three/drei';
import { GLTF } from 'three-stdlib';
import { useFrame, useThree } from '@react-three/fiber';
import getQuatWrist from '@/utils/get-quat-wrist';
import getVecOrth from '@/utils/get-vec-orth';
import getQuatTransformed from '@/utils/get-quat-transformed';
import { handIndices } from '@/utils/store';
import getRotMcp from '@/utils/get-rot-mcp';
type GLTFResult = GLTF & {
  nodes: {
    hand: THREE.SkinnedMesh;
    bone000: THREE.Bone;
  };
  materials: {
    ['Material #46']: THREE.MeshStandardMaterial;
  };
};
const quatWrist = new THREE.Quaternion();
// const quatWristSmoothed = new THREE.Quaternion(0, 0, 0, 1);
const quatWristBase = new THREE.Quaternion();
const quatIndexMcp = new THREE.Quaternion();
const quatIndexPip = new THREE.Quaternion();
const wristPosition = new THREE.Vector3();
const quatIndexMcpBase = new THREE.Quaternion();
const quatIndexPipBase = new THREE.Quaternion();

const quaternion1 = new THREE.Quaternion();
const quaternion2 = new THREE.Quaternion();
const quatFinal = new THREE.Quaternion();
// const quatWrist = new THREE.Quaternion();
// const quaternion2 = new ThreejsQuaternion();
const vectorBone = new THREE.Vector3();
const vecBonePos0 = new THREE.Vector3();
const vecBonePos1 = new THREE.Vector3();
const vecBonePos2 = new THREE.Vector3();
const vectorTrack = new THREE.Vector3();
const vecFrom = new THREE.Vector3();
const vecTo = new THREE.Vector3();

// const vectorTrack1 = new THREE.Vector3();

function addZeros(num, totalLength) {
  return `bone${String(num).padStart(totalLength, '0')}`;
}
const pointIndexMcp = 5;
const pointIndexPip = 6;
const pointIndexDip = 7;
const pointMidMcp = 9;
export default function HandMesh({ basePosRef, keypoints3dRef, ...props }) {
  const group = useRef<THREE.Group>(null!);
  const textRef = useRef<THREE.Mesh>(null!);
  const { nodes, materials } = useGLTF(
    '/gltf/hand_model_parented_sub.glb'
  ) as GLTFResult;
  const array1Ref = useRef('');
  const array2Ref = useRef([0, 0, 0]);

  const [text1State, setText1State] = useState('[0, 0, 0]');

  // useEffect(() => {
  //   // indexMcp.quaternion.identity();
  //   quatIndexMcpBase.copy(indexMcp.quaternion);
  //   quatIndexPipBase.copy(indexPip.quaternion);
  //   // quatIndexMcp.invert();
  //   // quatWrist.copy(wrist.quaternion);
  //   // baseQuatIndexMcp.copy(indexMcp.quaternion);
  // }, []);

  const { clock, viewport } = useThree();
  const prevVectorRef = useRef([0, 0, 1]);

  useFrame(() => {
    const wrist = nodes.hand.skeleton.bones[0];
    const midMcp = nodes.hand.skeleton.getBoneByName(
      `${addZeros(9, 3)}`
    ) as THREE.Bone;

    const indexMcp = nodes.hand.skeleton.getBoneByName(
      `${addZeros(5, 3)}`
    ) as THREE.Bone;
    const indexPip = nodes.hand.skeleton.getBoneByName(
      `${addZeros(6, 3)}`
    ) as THREE.Bone;
    const indexDip = nodes.hand.skeleton.getBoneByName(
      `${addZeros(7, 3)}`
    ) as THREE.Bone;

    // quatWrist.copy(wrist.quaternion);

    // quatWrist.copy(wrist.quaternion);

    // quatWrist.copy(
    getQuatWrist(nodes.hand.skeleton, keypoints3dRef.current, 0, 5, 13);
    // nodes.hand.matrixWorldNeedsUpdate = true;

    // console.log(nodes.hand.updateMatrixWorld());

    // console.log(nodes.hand.matrixWorld.toArray());
    // );

    // wrist.quaternion.slerp(quatWrist, 0.7);

    // console.log(wrist.matrix.toArray());
    // console.log(
    //   quatWrist
    //     .toArray()
    //     .map((val) => val.toFixed(4))
    //     .join()
    // );
    // wrist.quaternion.slerp(quatWrist, 0.65);
    // wrist.applyQuaternion(quatWrist);

    // indexMcp.getWorldPosition(vecBonePos0);
    // indexPip.getWorldPosition(vecBonePos1);
    // // midMcp.getWorldPosition(vecBonePos2);
    // // // pointMidMcp
    // vectorBone.subVectors(vecBonePos1, vecBonePos0).normalize();
    getRotMcp(
      nodes.hand.skeleton,
      keypoints3dRef.current,
      handIndices.pinkyMcp,
      handIndices.pinkyPip
    );
    getRotMcp(
      nodes.hand.skeleton,
      keypoints3dRef.current,
      handIndices.indexMcp,
      handIndices.indexPip
    );
    getRotMcp(
      nodes.hand.skeleton,
      keypoints3dRef.current,
      handIndices.middleMcp,
      handIndices.middlePip
    );

    getRotMcp(
      nodes.hand.skeleton,
      keypoints3dRef.current,
      handIndices.ringMcp,
      handIndices.ringPip
    );
    wristPosition.set(
      viewport.width * basePosRef.current[0],
      viewport.height * basePosRef.current[1],
      0
    );
    wrist.position.lerp(wristPosition, 0.75);
    // getRotMcp(
    //   nodes.hand.skeleton,
    //   keypoints3dRef.current,
    //   handIndices.indexPip,
    //   handIndices.indexDip
    // );

    // getRotMcp(
    //   wrist.quaternion,
    //   nodes.hand.skeleton,
    //   keypoints3dRef.current,
    //   handIndices.indexPip,
    //   handIndices.indexDip
    // );
    // vectorTrack
    //   .set(
    //     keypoints3dRef.current[pointIndexDip * 3 + 0] -
    //       keypoints3dRef.current[pointIndexPip * 3 + 0],
    //     keypoints3dRef.current[pointIndexDip * 3 + 1] -
    //       keypoints3dRef.current[pointIndexPip * 3 + 1],
    //     keypoints3dRef.current[pointIndexDip * 3 + 2] -
    //       keypoints3dRef.current[pointIndexPip * 3 + 2]
    //   )
    //   .normalize();
    // quaternion1.copy(wrist.quaternion).invert();
    // vectorTrack.applyQuaternion(quaternion1);

    // console.log(vectorTrack);

    // // const xRot = Math.sin(clock.getElapsedTime());

    // indexMcp.rotation.x = (Math.PI / 2) * vectorTrack.z;

    // indexMcp.rotation.y = -Math.PI / 10;
    // indexPip.rotation.x = Math.PI / 2;
    // indexDip.rotation.x = Math.PI / 2;
    // indexMcp.rotation.z = 0;
    // indexPip.
    // indexMcp.quaternion.x = xRot;
    // indexMcp.quaternion.w = Math.sqrt(1 - xRot * xRot);
    // console.log(indexMcp.quaternion.w);
    // console.log(indexMcp.quaternion);
    // indexPip.quaternion.slerp(quatIndexPip, 0.5);

    // indexDip.quaternion.slerp(quatIndexPip, 0.5);

    // console.log(indexPip);
    // indexTip.quaternion.slerp(quatIndexPip, 0.7);
    // indexPip.get(vecFrom);
    // vecTo.set(0, 1, 0);
    // indexMcp.lookAt(vecTo);
    // quatIndexMcp.copy(quatIndexMcpBase).premultiply(quatWrist);
    // getQuatWrist(
    //   quatIndexMcp,
    //   nodes.hand.skeleton,
    //   keypoints3dRef.current,
    //   5,
    //   6,
    //   9
    // );
    // quatIndexMcp.premultiply(wrist.quaternion);
    // quatIndexMcp.premultiply()
    // quatIndexMcp.invert();
    // indexMcp.getWorldDirection(vectorBone);
    // quaternion1.copy(quatWrist);
    // vectorBone.applyQuaternion(quaternion1);
    // quatIndexMcp.premultiply(quatWrist);

    // console.log(
    //   vecTo
    //     .toArray()
    //     .map((val) => val.toFixed(4))
    //     .join()
    // );
    // indexMcp.quat;
    // indexMcp.quaternion.copy(quatIndexMcp);

    // quaternion1.setFromUnitVectors(vectorBone, vectorTrack);
    // quatIndexMcp.multiply(quaternion1);
    // console.log(quaternion1.lengthSq());
    // .premultiply(quatWrist)
    // .premultiply(indexMcp.quaternion);
    // indexMcp.quaternion;
    // ////////////////////////////
    // console.log(vectorTrack);
    // vecFrom.copy(getVecOrth(vecBonePos0, vecBonePos1, vecBonePos2));
    // vecBonePos0.set(
    //   keypoints3dRef.current[pointIndexMcp * 3 + 0],
    //   keypoints3dRef.current[pointIndexMcp * 3 + 1],
    //   keypoints3dRef.current[pointIndexMcp * 3 + 2]
    // );
    // vecBonePos1.set(
    //   keypoints3dRef.current[pointIndexPip * 3 + 0],
    //   keypoints3dRef.current[pointIndexPip * 3 + 1],
    //   keypoints3dRef.current[pointIndexPip * 3 + 2]
    // );
    // vecBonePos2.set(
    //   keypoints3dRef.current[pointMidMcp * 3 + 0],
    //   keypoints3dRef.current[pointMidMcp * 3 + 1],
    //   keypoints3dRef.current[pointMidMcp * 3 + 2]
    // );
    // vecTo.copy(getVecOrth(vecBonePos0, vecBonePos1, vecBonePos2));

    // vecTo;
    // quaternion1.setFromUnitVectors(vectorBone, vectorTrack);
    // // .multiply(baseQuatIndexMcp);
    // // .multiply(quatWrist);

    // indexMcp.quaternion.copy(quaternion1);
    //   quaternion1.premultiply(quatWrist).multiply(baseQuatIndexMcp),
    //   0.75
    // );
    //   .premultiply(quatWrist);

    // quaternion2.copy(wrist.quaternion);
    // getQuatWrist(
    //   quaternion1,
    //   nodes.hand.skeleton,
    //   keypoints3dRef.current,
    //   5,
    //   6,
    //   13
    // );
    // quaternion2.multiplyQuaternions(quatWrist, quaternion1);
    // console.log(indexMcp.quaternion);
    // indexMcp.quaternion.slerp(quaternion1, 0.75);
    // console.log(baseQuatIndexMcp);
    // quaternion2.copy(indexMcp.quaternion);
    // quaternion1
    //   .copy(getQuatWrist(nodes.hand.skeleton, keypoints3dRef.current, 5, 6, 9))
    //   .multiply(quatWrist);

    // quaternion1
    //   .setFromUnitVectors(vectorBone, vectorTrack)
    //   .premultiply(quatWrist);
    // // quatFinal
    // midMcp.getWorldPosition(vecBonePos1);

    // quaternion2.premultiply(quaternion1).premultiply(quatWrist);

    // indexMcp.quaternion.slerp(quaternion1, 0.75);
    // console.log(indexMcp.quaternion);
    // console.log(indexPip.quaternion);
    // wrist.quaternion.slerp(quatWrist);

    // indexPip.quaternion.z += 0.1;

    // indexPip.rotation.x += 0.1;
  });

  return (
    <group ref={group} {...props} dispose={null}>
      <primitive object={nodes.bone000} />
      <skinnedMesh
        geometry={nodes.hand.geometry}
        material={materials['Material #46']}
        skeleton={nodes.hand.skeleton}
      />
    </group>
  );
}

useGLTF.preload('/gltf/hand_model_parented_sub.glb');

// setText1State(
//   wrist.position
//     .copy(wristPosition)
//     .toArray()
//     .map((val) => val.toFixed(4))
//     .join()
// );
