/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three';
import React, { useEffect, useRef, useState } from 'react';
import {
  // Text,
  useGLTF,
} from '@react-three/drei';
import { GLTF } from 'three-stdlib';
import { useFrame, useThree } from '@react-three/fiber';
import getQuatWrist from '@/utils/get-quat-wrist';
import getVecOrth from '@/utils/get-vec-orth';
type GLTFResult = GLTF & {
  nodes: {
    hand: THREE.SkinnedMesh;
    bone000: THREE.Bone;
  };
  materials: {
    ['Material #46']: THREE.MeshStandardMaterial;
  };
};
const quaternionWrist = new THREE.Quaternion(0, 0, 0, 1);
// const quatWristSmoothed = new THREE.Quaternion(0, 0, 0, 1);
const baseQuaternionWrist = new THREE.Quaternion(0, 0, 0, 1);
const wristPosition = new THREE.Vector3();

const quaternion1 = new THREE.Quaternion();
const quaternion2 = new THREE.Quaternion();
const quatFinal = new THREE.Quaternion();
// const quaternionWrist = new THREE.Quaternion();
// const quaternion2 = new ThreejsQuaternion();
const vectorBone = new THREE.Vector3();
const vectorBonePos0 = new THREE.Vector3();
const vectorBonePos1 = new THREE.Vector3();
// const vectorBone1 = new THREE.Vector3();
const vectorTrack = new THREE.Vector3();
// const vectorTrack1 = new THREE.Vector3();

function addZeros(num, totalLength) {
  return `bone${String(num).padStart(totalLength, '0')}`;
}
const pointIndexMcp = 5;
const pointIndexPip = 6;
const pointMidMcp = 9;
export default function HandMesh({ basePosRef, keypoints3dRef, ...props }) {
  const group = useRef<THREE.Group>(null!);
  const textRef = useRef<THREE.Mesh>(null!);
  const { nodes, materials } = useGLTF(
    '/gltf/hand_model_parented_sub.glb'
  ) as GLTFResult;
  const array1Ref = useRef('');
  const array2Ref = useRef([0, 0, 0]);
  const wrist = nodes.hand.skeleton.bones[0];
  const [text1State, setText1State] = useState('[0, 0, 0]');

  const midMcp = nodes.hand.skeleton.getBoneByName(
    `${addZeros(9, 3)}`
  ) as THREE.Bone;

  const indexMcp = nodes.hand.skeleton.getBoneByName(
    `${addZeros(5, 3)}`
  ) as THREE.Bone;
  const indexPip = nodes.hand.skeleton.getBoneByName(
    `${addZeros(6, 3)}`
  ) as THREE.Bone;
  const index_dip = nodes.hand.skeleton.getBoneByName(
    `${addZeros(7, 3)}`
  ) as THREE.Bone;
  const index_tip = nodes.hand.skeleton.getBoneByName(
    `${addZeros(8, 3)}`
  ) as THREE.Bone;
  useEffect(() => {
    baseQuaternionWrist.copy(wrist.quaternion);
  }, []);

  const { clock, viewport } = useThree();
  const prevVectorRef = useRef([0, 0, 1]);

  useFrame(() => {
    wristPosition.set(
      viewport.width * basePosRef.current[0],
      viewport.height * basePosRef.current[1],
      0
    );
    // quaternionWrist.copy(
    getQuatWrist(
      quaternionWrist,
      nodes.hand.skeleton,
      keypoints3dRef.current,
      0,
      1,
      13
    );
    // );

    wrist.position.lerp(wristPosition, 0.4);
    wrist.quaternion.slerp(quaternionWrist, 0.75);
    // wrist.applyQuaternion(quaternionWrist);

    indexMcp.getWorldPosition(vectorBonePos0);
    indexPip.getWorldPosition(vectorBonePos1);
    // pointMidMcp
    vectorBone.subVectors(vectorBonePos1, vectorBonePos0).normalize();
    vectorTrack
      .set(
        keypoints3dRef.current[pointIndexPip * 3 + 0] -
          keypoints3dRef.current[pointIndexMcp * 3 + 0],
        keypoints3dRef.current[pointIndexPip * 3 + 1] -
          keypoints3dRef.current[pointIndexMcp * 3 + 1],
        keypoints3dRef.current[pointIndexPip * 3 + 2] -
          keypoints3dRef.current[pointIndexMcp * 3 + 2]
      )
      .normalize();
    quaternion1
      .setFromUnitVectors(vectorBone, vectorTrack)
      .premultiply(quaternionWrist);

    // quaternion2.copy(wrist.quaternion);
    // getQuatWrist(
    //   quaternion1,
    //   nodes.hand.skeleton,
    //   keypoints3dRef.current,
    //   5,
    //   6,
    //   13
    // );
    // quaternion2.multiplyQuaternions(quaternionWrist, quaternion1);
    // console.log(indexMcp.quaternion);
    indexMcp.quaternion.slerp(quaternion1, 0.75);
    // quaternion2.copy(indexMcp.quaternion);
    // quaternion1
    //   .copy(getQuatWrist(nodes.hand.skeleton, keypoints3dRef.current, 5, 6, 9))
    //   .multiply(quaternionWrist);

    // quaternion1
    //   .setFromUnitVectors(vectorBone, vectorTrack)
    //   .premultiply(quaternionWrist);
    // // quatFinal
    // midMcp.getWorldPosition(vectorBonePos1);

    // quaternion2.premultiply(quaternion1).premultiply(quaternionWrist);

    // indexMcp.quaternion.slerp(quaternion1, 0.75);
    // console.log(indexMcp.quaternion);
    // console.log(indexPip.quaternion);
    // wrist.quaternion.slerp(quaternionWrist);

    // indexPip.quaternion.z += 0.1;

    // indexPip.rotation.x += 0.1;
  });

  return (
    <group ref={group} {...props} dispose={null}>
      <primitive object={nodes.bone000} />
      <skinnedMesh
        geometry={nodes.hand.geometry}
        material={materials['Material #46']}
        skeleton={nodes.hand.skeleton}
      />
    </group>
  );
}

useGLTF.preload('/gltf/hand_model_parented_sub.glb');

// setText1State(
//   wrist.position
//     .copy(wristPosition)
//     .toArray()
//     .map((val) => val.toFixed(4))
//     .join()
// );
